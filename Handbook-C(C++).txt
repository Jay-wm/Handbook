为什么在C++语言中要增加运算符new/delete?为什么在C++语言中不把malloc/free删除掉呢？

================================================================================================================================================

一、区别：
1、malloc/free是 C/C++ 语言的标准库函数；new/delete是C++的运算符。
2、malloc/free只负责分配和释放内存；而new/delete不仅负责分配和释放内存，而且还会自动调用构造函数和析构函数。即，从功能上讲，前者是后者的子集。所以，前者返回的是void类型的指针，而后者返回的是带类型信息的指针。
3、为什么在C++语言中要增加运算符new/delete？
  这是因为对于用户自定义的对象而言，用maloc/free无法满足动态管理对象的要求。
  对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。（记住：是增加具有new/delete一样功能的运算符，而非具有new/delete一样功能的函数）
4、内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行，而malloc没有这些信息。

二、联系
1、new/delete在实现上，调用了malloc/free函数。
2、既然在功能上，malloc/free是new/delete的子集，为什么在C++语言中不把malloc/free删除掉呢？
   这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
3、由于内部数据类型的“对象”没有构造与析构的过程，所以对它们而言，malloc/free和new/delete是等价的。（对比“区别3”中的用户自定义的对象）




动态库与静态库
一、区别
1、动态库成对生成 xxx.dll/xxx.lib文件
   静态库只生成 xxx.lib文件
2、其他项目引用时
  链接器 --> 常规 --> 附加库目录 --> 添加xxx.lib文件路径
  链接器 --> 输入 --> 附加依赖项 --> 添加xxx.lib文件
  xxx.dll在调试时可以不放在exe文件路径下，exe执行时必须有


三、#x、##x、x##、##x##、变量作用
（1）#变量
在C语言的宏中，#的功能是将其后面的宏参数进行字符串化操作（Stringfication），简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号
（2）##变量
## 被称为连接符（concatenator），用来将两个Token连接为一个Token。注意这里连接的对象是Token就行，而不一定是宏的变量。比如你要做一个菜单项命令名和函数指针组成的结构体的数组，并且希望在函数名和菜单项命令名之间有直观的、名字上的关系。
#define LINK_MULTIPLE(a,b,c,d) a##_##b##_##c##_##d //注意这里的规则（a##开头，##d结束，中间都用##x##）
typedef struct _record_type LINK_MULTIPLE(name,company,position,salary);
