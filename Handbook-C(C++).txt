为什么在C++语言中要增加运算符new/delete?为什么在C++语言中不把malloc/free删除掉呢？

================================================================================================================================================

一、区别：
1、malloc/free是 C/C++ 语言的标准库函数；new/delete是C++的运算符。
2、malloc/free只负责分配和释放内存；而new/delete不仅负责分配和释放内存，而且还会自动调用构造函数和析构函数。即，从功能上讲，前者是后者的子集。所以，前者返回的是void类型的指针，而后者返回的是带类型信息的指针。
3、为什么在C++语言中要增加运算符new/delete？
  这是因为对于用户自定义的对象而言，用maloc/free无法满足动态管理对象的要求。
  对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。（记住：是增加具有new/delete一样功能的运算符，而非具有new/delete一样功能的函数）
4、内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行，而malloc没有这些信息。

二、联系
1、new/delete在实现上，调用了malloc/free函数。
2、既然在功能上，malloc/free是new/delete的子集，为什么在C++语言中不把malloc/free删除掉呢？
   这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
3、由于内部数据类型的“对象”没有构造与析构的过程，所以对它们而言，malloc/free和new/delete是等价的。（对比“区别3”中的用户自定义的对象）
